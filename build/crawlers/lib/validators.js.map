{"version":3,"sources":["crawlers/lib/validators.js"],"names":["validateParse","isNotEmptyString","isNumber","isNotEmptyArray","isNotElementNotFound","isDate","fnc","validators","parserName","name","errorWrapperForParserFunctions","element","arguments","result","apply","elementToLog","html","forEach","validator","slice","v","length","ELEMENT_NOT_FOUND"],"mappings":";;;;;;QAWgBA,a,GAAAA,a;QAoBAC,gB,GAAAA,gB;QAIAC,Q,GAAAA,Q;QAIAC,e,GAAAA,e;QAMAC,oB,GAAAA,oB;QAIAC,M,GAAAA,M;;AAjDhB;;AACA;;AAEA;;;;;;;;AAQO,SAASL,aAAT,CAAuBM,GAAvB,EAA4BC,UAA5B,EAAwC;AAAE;AAC7C,QAAMC,aAAaF,IAAIG,IAAvB;;AAEA,aAASC,8BAAT,GAA0C;AACtC,YAAMC,UAAUC,UAAU,CAAV,CAAhB;AACA,YAAMC,SAASP,IAAIQ,KAAJ,CAAU,IAAV,EAAgBF,SAAhB,CAAf;AACA,YAAMG,eAAeJ,QAAQK,IAAR,GAAeL,QAAQK,IAAR,EAAf,GAAgCL,OAArD;;AAEAJ,mBAAWU,OAAX,CAAmB,UAACC,SAAD,EAAc;AAC7B,gBAAI,CAACA,UAAUL,MAAV,CAAL,EAAwB;AACpB,sBAAM,6BAAgBE,aAAaI,KAAb,CAAmB,CAAnB,EAAsB,GAAtB,CAAhB,EAA4CX,UAA5C,EAAwDU,UAAUT,IAAlE,CAAN;AACH;AACJ,SAJD;;AAMA,eAAOI,MAAP;AACH;;AAED,WAAOH,8BAAP;AACH;;AAEM,SAAST,gBAAT,CAA0BmB,CAA1B,EAA6B;AAChC,WAAOA,MAAM,EAAb;AACH;;AAEM,SAASlB,QAAT,CAAkBkB,CAAlB,EAAqB;AACxB,WAAO,sBAAUA,CAAV,CAAP;AACH;;AAEM,SAASjB,eAAT,CAAyBiB,CAAzB,EAA4B;AAC/B,WAAO,qBAAQA,CAAR,KAAcA,EAAEC,MAAF,GAAW,CAAhC;AACH;;AAEM,IAAMC,gDAAoB,qBAA1B;;AAEA,SAASlB,oBAAT,CAA8BgB,CAA9B,EAAiC;AACpC,WAAOA,MAAME,iBAAb;AACH;;AAEM,SAASjB,MAAT,CAAgBe,CAAhB,EAAmB;AACtB,WAAO,oBAAQA,CAAR,CAAP;AACH","file":"crawlers/lib/validators.js","sourcesContent":["import { isArray, isFinite as isNumber_, isDate as isDate_ } from 'lodash'\nimport { makeParserError } from './errors'\n\n/**\n * Wraps a html parser function and validates its return value against\n * supplied validators. On validation fail, throw custom parser error.\n *\n * @param {Function} fnc\n * @param {Array} validators\n * @returns {Function}\n */\nexport function validateParse(fnc, validators) { //TODO test\n    const parserName = fnc.name;\n\n    function errorWrapperForParserFunctions() {\n        const element = arguments[0];\n        const result = fnc.apply(this, arguments);\n        const elementToLog = element.html ? element.html() : element;\n\n        validators.forEach((validator)=> {\n            if (!validator(result)) {\n                throw makeParserError(elementToLog.slice(0, 300), parserName, validator.name)\n            }\n        });\n\n        return result\n    }\n\n    return errorWrapperForParserFunctions\n}\n\nexport function isNotEmptyString(v) {\n    return v !== ''\n}\n\nexport function isNumber(v) {\n    return isNumber_(v)\n}\n\nexport function isNotEmptyArray(v) {\n    return isArray(v) && v.length > 0\n}\n\nexport const ELEMENT_NOT_FOUND = '@@ELEMENT_NOT_FOUND';\n\nexport function isNotElementNotFound(v) {\n    return v !== ELEMENT_NOT_FOUND\n}\n\nexport function isDate(v) {\n    return isDate_(v)\n}\n\n\n\n"],"sourceRoot":"/source/"}