{"version":3,"sources":["crawlers/lib/queueWorkerFactory.js"],"names":["queueWorkerFactory","sleep","ms","Promise","resolve","setTimeout","asyncRetry","fnc","times","delay","args","arguments","that","failed","reject","runSingleTry","apply","then","r","catch","e","taskConsumer","taskFailureCallback","taskSuccessCallback","task","callback","result","retry","retryInterval","success","error","worker"],"mappings":";;;;;QA6BgBA,kB,GAAAA,kB;;;;AA7BhB,SAASC,KAAT,CAAeC,EAAf,EAAmB;AACf,WAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAY;AAC3BC,mBAAWD,OAAX,EAAoBF,EAApB;AACH,KAFM,CAAP;AAGH;;AAED,SAASI,UAAT,CAAoBC,GAApB,EAAyBC,KAAzB,EAA6C;AAAA,QAAbC,KAAa,yDAAL,GAAK;AAAE;AAC3C,WAAO,YAAW;AACd,YAAMC,OAAOC,SAAb;AACA,YAAMC,OAAO,IAAb;AACA,YAAIC,SAAS,CAAb;;AAEA,eAAO,IAAIV,OAAJ,CAAY,UAACC,OAAD,EAAUU,MAAV,EAAoB;AACnC,qBAASC,YAAT,GAAwB;AACpBR,oBAAIS,KAAJ,CAAUJ,IAAV,EAAgBF,IAAhB,EACKO,IADL,CACU;AAAA,2BAAIb,QAAQc,CAAR,CAAJ;AAAA,iBADV,EAEKC,KAFL,CAEW,UAACC,CAAD,EAAM;AACT,sBAAEP,MAAF;;AAEA,wBAAIA,SAASL,KAAb,EAAoBH,WAAWU,YAAX,EAAyBN,KAAzB,EAApB,KACKK,OAAOM,CAAP;AACR,iBAPL;AAQH;;AAEDL;AACH,SAbM,CAAP;AAcH,KAnBD;AAoBH;;AAEM,SAASf,kBAAT,CAA4BqB,YAA5B,EAA0CC,mBAA1C,EAA+DC,mBAA/D,EAAoF;;AAEvF;AAAA,6DAAO,iBAAsBC,IAAtB,EAA4BC,QAA5B;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,kCADD;AAAA;;AAAA,iCAIKF,KAAKf,KAJV;AAAA;AAAA;AAAA;;AAAA;AAAA,mCAIuBR,MAAMuB,KAAKf,KAAX,CAJvB;;AAAA;AAAA,iCAMKe,KAAKG,KANV;AAAA;AAAA;AAAA;;AAAA;AAAA,mCAOoBrB,WAAWe,YAAX,EAAyBG,KAAKG,KAA9B,EAAqCH,KAAKI,aAA1C,EAAyDJ,IAAzD,CAPpB;;AAAA;AAOKE,kCAPL;AAAA;AAAA;;AAAA;AAAA;AAAA,mCASoBL,aAAaG,IAAb,CATpB;;AAAA;AASKE,kCATL;;AAAA;;AAYCH,gDAAoB;AAChBM,yCAAS,IADO;AAEhBL,0CAFgB;AAGhBE;AAHgB,6BAApB;AAZD;AAAA;;AAAA;AAAA;AAAA;;AAkBCJ,gDAAoB;AAChBO,yCAAS,KADO;AAEhBL,0CAFgB;AAGhBM;AAHgB,6BAApB;;AAlBD;AAAA;;AAwBCL;AAxBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAP;;AAAA,iBAAsBM,MAAtB;AAAA;AAAA;;AAAA,eAAsBA,MAAtB;AAAA;AA2BH","file":"crawlers/lib/queueWorkerFactory.js","sourcesContent":["function sleep(ms) {\n    return new Promise((resolve)=> {\n        setTimeout(resolve, ms)\n    })\n}\n\nfunction asyncRetry(fnc, times, delay = 100) { //TODO test\n    return function() {\n        const args = arguments;\n        const that = this;\n        let failed = 0;\n\n        return new Promise((resolve, reject)=> {\n            function runSingleTry() {\n                fnc.apply(that, args)\n                    .then(r=> resolve(r))\n                    .catch((e)=> {\n                        ++failed;\n\n                        if (failed < times) setTimeout(runSingleTry, delay);\n                        else reject(e)\n                    })\n            }\n\n            runSingleTry()\n        })\n    }\n}\n\nexport function queueWorkerFactory(taskConsumer, taskFailureCallback, taskSuccessCallback) {\n\n    return async function worker(task, callback) {\n        let result;\n\n        try {\n            if (task.delay) await sleep(task.delay);\n\n            if (task.retry) {\n                result = await asyncRetry(taskConsumer, task.retry, task.retryInterval)(task)\n            } else {\n                result = await taskConsumer(task);\n            }\n\n            taskSuccessCallback({\n                success: true,\n                task,\n                result\n            })\n        } catch (error) {\n            taskFailureCallback({\n                success: false,\n                task,\n                error\n            })\n        } finally {\n            callback()\n        }\n    }\n}"],"sourceRoot":"/source/"}