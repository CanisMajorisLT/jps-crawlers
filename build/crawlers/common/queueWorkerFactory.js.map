{"version":3,"sources":["crawlers/common/queueWorkerFactory.js"],"names":[],"mappings":";;;;;QA6BgB,kB,GAAA,kB;;;;AA7BhB,SAAS,KAAT,CAAe,EAAf,EAAmB;AACf,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAY;AAC3B,mBAAW,OAAX,EAAoB,EAApB;AACH,KAFM,CAAP;AAGH;;AAED,SAAS,UAAT,CAAoB,GAApB,EAAyB,KAAzB,EAA6C;AAAA,QAAb,KAAa,yDAAL,GAAK;;AACzC,WAAO,YAAW;AACd,YAAM,OAAO,SAAb;AACA,YAAM,OAAO,IAAb;AACA,YAAI,SAAS,CAAb;;AAEA,eAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AACnC,qBAAS,YAAT,GAAwB;AACpB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,IAAhB,EACK,IADL,CACU;AAAA,2BAAI,QAAQ,CAAR,CAAJ;AAAA,iBADV,EAEK,KAFL,CAEW,UAAC,CAAD,EAAM;AACT,sBAAE,MAAF;;AAEA,wBAAI,SAAS,KAAb,EAAoB,WAAW,YAAX,EAAyB,KAAzB,EAApB,KACK,OAAO,CAAP;AACR,iBAPL;AAQH;;AAED;AACH,SAbM,CAAP;AAcH,KAnBD;AAoBH;;AAEM,SAAS,kBAAT,CAA4B,YAA5B,EAA0C,mBAA1C,EAA+D,mBAA/D,EAAoF;;AAEvF;AAAA,4DAAO,iBAAsB,IAAtB,EAA4B,QAA5B;AAAA,gBACC,MADD;AAAA;AAAA;AAAA;AAAA;AACC,kCADD;AAAA;;AAAA,iCAIK,KAAK,KAJV;AAAA;AAAA;AAAA;;AAAA;AAAA,mCAIuB,MAAM,KAAK,KAAX,CAJvB;;AAAA;AAAA,iCAMK,KAAK,KANV;AAAA;AAAA;AAAA;;AAAA;AAAA,mCAOoB,WAAW,YAAX,EAAyB,KAAK,KAA9B,EAAqC,KAAK,aAA1C,EAAyD,IAAzD,CAPpB;;AAAA;AAOK,kCAPL;AAAA;AAAA;;AAAA;AAAA;AAAA,mCASoB,aAAa,IAAb,CATpB;;AAAA;AASK,kCATL;;AAAA;;AAYC,gDAAoB;AAChB,yCAAS,IADO;AAEhB,0CAFgB;AAGhB;AAHgB,6BAApB;AAZD;AAAA;;AAAA;AAAA;AAAA;;AAkBC,gDAAoB;AAChB,yCAAS,KADO;AAEhB,0CAFgB;AAGhB;AAHgB,6BAApB;;AAlBD;AAAA;;AAwBC;AAxBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAP;;AAAA,iBAAsB,MAAtB;AAAA;AAAA;;AAAA,eAAsB,MAAtB;AAAA;AA2BH","file":"crawlers/common/queueWorkerFactory.js","sourcesContent":["function sleep(ms) {\r\n    return new Promise((resolve)=> {\r\n        setTimeout(resolve, ms)\r\n    })\r\n}\r\n\r\nfunction asyncRetry(fnc, times, delay = 100) { //TODO test\r\n    return function() {\r\n        const args = arguments;\r\n        const that = this;\r\n        let failed = 0;\r\n\r\n        return new Promise((resolve, reject)=> {\r\n            function runSingleTry() {\r\n                fnc.apply(that, args)\r\n                    .then(r=> resolve(r))\r\n                    .catch((e)=> {\r\n                        ++failed;\r\n\r\n                        if (failed < times) setTimeout(runSingleTry, delay);\r\n                        else reject(e)\r\n                    })\r\n            }\r\n\r\n            runSingleTry()\r\n        })\r\n    }\r\n}\r\n\r\nexport function queueWorkerFactory(taskConsumer, taskFailureCallback, taskSuccessCallback) {\r\n\r\n    return async function worker(task, callback) {\r\n        let result;\r\n\r\n        try {\r\n            if (task.delay) await sleep(task.delay);\r\n\r\n            if (task.retry) {\r\n                result = await asyncRetry(taskConsumer, task.retry, task.retryInterval)(task)\r\n            } else {\r\n                result = await taskConsumer(task);\r\n            }\r\n\r\n            taskSuccessCallback({\r\n                success: true,\r\n                task,\r\n                result\r\n            })\r\n        } catch (error) {\r\n            taskFailureCallback({\r\n                success: false,\r\n                task,\r\n                error\r\n            })\r\n        } finally {\r\n            callback()\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}