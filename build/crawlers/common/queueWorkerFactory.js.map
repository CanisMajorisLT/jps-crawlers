{"version":3,"sources":["crawlers/common/queueWorkerFactory.js"],"names":[],"mappings":";;;;;QA6BgB;;;;AA7BhB,SAAS,KAAT,CAAe,EAAf,EAAmB;AACf,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAY;AAC3B,mBAAW,OAAX,EAAoB,EAApB,EAD2B;KAAZ,CAAnB,CADe;CAAnB;;AAMA,SAAS,UAAT,CAAoB,GAApB,EAAyB,KAAzB,EAA6C;QAAb,8DAAQ,mBAAK;;AACzC,WAAO,YAAW;AACd,YAAM,OAAO,SAAP,CADQ;AAEd,YAAM,OAAO,IAAP,CAFQ;AAGd,YAAI,SAAS,CAAT,CAHU;;AAKd,eAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AACnC,qBAAS,YAAT,GAAwB;AACpB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,IAAhB,EACK,IADL,CACU;2BAAI,QAAQ,CAAR;iBAAJ,CADV,CAEK,KAFL,CAEW,UAAC,CAAD,EAAM;AACT,sBAAE,MAAF,CADS;;AAGT,wBAAI,SAAS,KAAT,EAAgB,WAAW,YAAX,EAAyB,KAAzB,EAApB,KACK,OAAO,CAAP,EADL;iBAHG,CAFX,CADoB;aAAxB;;AAWA,2BAZmC;SAApB,CAAnB,CALc;KAAX,CADkC;CAA7C;;AAuBO,SAAS,kBAAT,CAA4B,YAA5B,EAA0C,mBAA1C,EAA+D,mBAA/D,EAAoF;;AAEvF;4DAAO,iBAAsB,IAAtB,EAA4B,QAA5B;gBACC;;;;;;;;iCAGI,KAAK,KAAL;;;;;;mCAAkB,MAAM,KAAK,KAAL;;;iCAExB,KAAK,KAAL;;;;;;mCACe,WAAW,YAAX,EAAyB,KAAK,KAAL,EAAY,KAAK,aAAL,CAArC,CAAyD,IAAzD;;;AAAf;;;;;;mCAEe,aAAa,IAAb;;;AAAf;;;;AAGJ,gDAAoB;AAChB,yCAAS,IAAT;AACA,0CAFgB;AAGhB,8CAHgB;6BAApB;;;;;;;;AAMA,gDAAoB;AAChB,yCAAS,KAAT;AACA,0CAFgB;AAGhB,kDAHgB;6BAApB;;;;;AAMA;;;;;;;;;SAxBD;;wBAAe;;;OAAtB,CAFuF;CAApF","file":"crawlers/common/queueWorkerFactory.js","sourcesContent":["function sleep(ms) {\r\n    return new Promise((resolve)=> {\r\n        setTimeout(resolve, ms)\r\n    })\r\n}\r\n\r\nfunction asyncRetry(fnc, times, delay = 100) { //TODO test\r\n    return function() {\r\n        const args = arguments;\r\n        const that = this;\r\n        let failed = 0;\r\n\r\n        return new Promise((resolve, reject)=> {\r\n            function runSingleTry() {\r\n                fnc.apply(that, args)\r\n                    .then(r=> resolve(r))\r\n                    .catch((e)=> {\r\n                        ++failed;\r\n\r\n                        if (failed < times) setTimeout(runSingleTry, delay);\r\n                        else reject(e)\r\n                    })\r\n            }\r\n\r\n            runSingleTry()\r\n        })\r\n    }\r\n}\r\n\r\nexport function queueWorkerFactory(taskConsumer, taskFailureCallback, taskSuccessCallback) {\r\n\r\n    return async function worker(task, callback) {\r\n        let result;\r\n\r\n        try {\r\n            if (task.delay) await sleep(task.delay);\r\n\r\n            if (task.retry) {\r\n                result = await asyncRetry(taskConsumer, task.retry, task.retryInterval)(task)\r\n            } else {\r\n                result = await taskConsumer(task);\r\n            }\r\n\r\n            taskSuccessCallback({\r\n                success: true,\r\n                task,\r\n                result\r\n            })\r\n        } catch (error) {\r\n            taskFailureCallback({\r\n                success: false,\r\n                task,\r\n                error\r\n            })\r\n        } finally {\r\n            callback()\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}